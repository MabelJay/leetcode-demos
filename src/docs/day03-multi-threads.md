# 第一章 并发编程
上下文切换：CPU是通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。
但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以，
任务从保存到再加载的过程就是一次上下文切换。

## 如何减少上下文切换
减少上下文切换的方法有：无锁并发编程、CAS算法、使用最少线程和使用协程。
ps: 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的转换。

## 避免死锁的几个常见方法：
1. 避免一个线程同时获取多个锁
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3. 尝试使用定时锁
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

# 第二章 Java并发机制的底层实现原理
## volatile的应用
保证可见性、禁止指令重排序

lock汇编代码指令：
lock前缀的指令在多核处理器下会引发两件事情：1. 将当前处理器缓存行的数据写回到系统内存。
2.这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。

## 锁的升级与对比
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程
在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试一下对象头的Mark Word里是否存储
着指向当前线程的偏向锁。  
轻量级锁：轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回对象头，如果成功，则表示
没有竞争，如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

因为自旋会消耗CPU，为了避免无用的自旋，一旦锁升级成重量级锁，就不会再恢复到轻量级锁。

## 原子操作的实现原理
原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。  
### 多处理器上实现原子操作：
基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。
总线锁：使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，
那么该处理器可以独占共享内存。  
缓存锁：总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。
所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到
内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。

两种情况下处理器不会使用缓存锁定：
1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。
2. 有些处理器不支持缓存锁定。
### Java如何实现原子操作
在Java中通过锁和循环CAS的方式来实现原子操作。
1. 使用循环CAS实现原子操作：利用率处理器提供的cmpxchg指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。
从JDK1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean、AtomicInteger和AtomicLong。这些原子包装类
还提供了有用的工具方法，如compareAndSet以原子的方式将当前值自增1和自减1.  

CAS实现原子操作的三大问题：1. ABA问题：解决思路是使用版本号，JDK的Atomic包里提供了一个类AtomicStampedReference来
解决ABA问题，2.循环时间长开销大 3. 只能保证一个共享变量的原子操作。从JDK1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，
就可以把多个变量放在一个对象里来进行CAS操作。

2. 使用锁机制实现原子操作
锁机制保证了只有获得锁的线程才能够操作锁定的内存区域，JVM内部是西安了很多种锁机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都
使用了循环CAS，既当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。

# 第三章 Java内存模型
## Java内存模型的基础
并发编程需要解决的两个问题：线程之间如何通信以及线程之间如何同步。通信指的是线程之间以何种机制来交换信息，
在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。同步是指程序中用于控制不同线程间操作发生相对顺序的机制。
在共享内存并发模型中，同步是显式进行的。程序员必须显示指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须
在消息的接收之前，因此同步是隐式进行的。



